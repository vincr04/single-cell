# Single-cell RNA-seq workshop
January 2025 version

In this workshop, we will learn how to analyse single-cell RNA-seq data using the Seurat software. This simplified exercise is inspired by the [original Seurat tutorial by Rahul Satija et al.](https://satijalab.org/seurat/articles/pbmc3k_tutorial)
This document contains a mix of explainations in plain text, `elements of code that you can type in R`, and 
>Tasks or questions that you can try and answer, either on your own or by groups of 2-3.  

There is no report to submit, so you can just focus on **understanding** how the analysis works. There is no need to speed through the instructions. Instead, it is important that you make sure you understand the importance of each step, the structure of the different objects involved, and what the different commands do. There are some optional questions - it is probably best if you try and answer them in the end, if you still have time.   
**We are available to help if you have any question or if anything is unclear.**  
***

## 1. Preparation

### Install the software

You should have [RStudio](https://posit.co/downloads/) installed on your computer.

Seurat runs in R and is available as a package via CRAN, which is the main repository for R packages. Instructions about how to install Seurat are available [here](https://satijalab.org/seurat/articles/install_v5). In brief, to install and load Seurat, you need to type the following commands:
```{r eval=F}
install.packages('Seurat')
library(Seurat)
```
*Remember, code is ALWAYS case-sensitive*. Once this is done, move to the next step.

### Additional packages to install

We will use [tidyverse](https://www.tidyverse.org/) to manipulate data. Tidyverse is available via CRAN. You should have it installed since the RNA-seq workshop, but if you need to install it, you can do so from the 'Packages' tab on the top right of your screen in RStudio, or the command below. Then, load the package.  

[ggplot2](https://ggplot2.tidyverse.org/reference/ggplot.html). Likewise, if it's already installed on your computer you can just load the package. Otherwise, you can also install it from CRAN. Then, load the package.

Do also install the [patchwork](https://patchwork.data-imaginist.com/) library, which is required for combining multiople ggplots into the same graphic. Don't forget to load it too.

```{r eval=F}
install.packages("tidyverse")
library("tidyverse")

install.packages("ggplot2")
library("ggplot2")

install.packages("patchwork")
library("patchwork")
```


## 2. Get the data

We will work with an existing single-cell RNA-seq dataset that is often used as an example for students, or by researchers who are developing and testing new methods for analysis. This dataset contains ~3,000 **peripheral blood mononuclear cells**, generated by 10X Genomics. You can download the data using [this link.](https://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz) 
Make sure you save the data in a new folder dedicated to this workshop. Double-click on the file to unzip it - you should see a new folder called `filtered_gene_bc_matrices` appear, which contains another folder called `hg19`, which contains three files. 

> What are these three files?

Load this data into R, using the `Read10X` function, which merges the information from these three files into a single R object:
```{r eval=F}
pbmc.data <- Read10X(data.dir = "/path/to/filtered_gene_bc_matrices/hg19/") # This should be the path to the 'hg19' folder
```

> View the `pbmc.data` object. How is the data structured? Can you tell how many genes and cells are in this dataset?

<br/>

## 3. Create a *Seurat object*

Like DESeq2, Seurat uses a dedicated object class for storing its data. Using the `CreateSeuratObject` function, you can generate your own Seurat object for the pbmc data:
```{r eval=F}
pbmc <- CreateSeuratObject(counts = pbmc.data, project = "pbmc3k", min.cells = 3, min.features = 200)
pbmc # to visualise basic information about your new 'pbmc' object.
pbmc@meta.data # to display the meta data associated with this object
```
> What are the `min.cells` and `min.features` options for? 
> Why does the `pbmc` Seurat object include less genes than the original data you downloaded?
> What do the different columns in the metadata represent. What is the difference between nCount and nFeature?

**Note** that single-cell datasets mostly contain 'zero' values, due to the fact that only a relatively small fraction of all the genes are detected in each cell. These values are represented by a '.' instead of a '0' to allow Seurat to save space and memory by only saving the non-zero values and their coordinates, instead of the whole matrix.

<br/>

## 4. Quality control

To improve our analysis, we need to exclude *low quality* barcodes, according to the following metrics: 
- barcodes with too many genes are likely to contain RNA from more than one cell.
- barcodes with too few genes are likely to contain ambient RNA or RNA from broken/lysed cells.
- barcodes with a high percentage (>5%) of mitochondrial transcripts probably represent cells that are unhealthy/dying.

We first plot the number of genes (features) and UMIs (counts) for each cell:
```{r}
ggplot(pbmc@meta.data, aes(x=nCount_RNA, y=nFeature_RNA)) + geom_point() + geom_hline(yintercept=2000, colour="red")
```

We can see that most cells have <2,000 genes detected. Those containing more than 2,000 different genes are likely outliers, so they can be removed. 

Mitochondrial metrics can be calculated with the `PercentageFeatureSet` function, which calculates the percentage of counts originating from a set of features. 

```{r}
# We use the '[[' operator to add columns to object metadata. 
pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-") 
# the 'pattern' option indicates what pattern to look for in the gene name. This command will only work if mitochondrial genes names start with "MT-", e.g., MT-ND2

# We can use a Violin Plot to visualise the percentage of mitochondrial genes in each cell:
VlnPlot(pbmc, features="percent.mt") + geom_hline(yintercept=5) # adding a line at 5%
```
As with numbers of genes, we see that a few cells fall outside of our criteria. 

We can now remove low quality cells, using the `subset` function. 
```{r}
pbmc <- subset(pbmc, subset = nFeature_RNA<2000 & percent.mt<5) # keep cells with <2000 genes and <5% MT 
```

> Can you tell how many cells have been removed? 
> Check the metadata again. What has changed?
> OPTIONAL: run the last two plots again, to confirm that outlier cells are no longer here. 

## 5. Normalise the data

Normalising the data has two purposes: 
1. To prevent biases arising from the fact that each cell contains a different total number of transcripts (`nCount`). 
2. Log-transforming the results also helps with further processing of the data. 
```{r}
pbmc <- NormalizeData(pbmc, normalization.method = "LogNormalize", scale.factor = 10000) # 'scale factor' is an arbitrary number representing the total number of transcripts that we want each cell to contain. 
```

This operation creates a new `layer` in the Seurat object, which can be accessed using the following command:
```{r}
pbmc@assays$RNA@layers$counts[1:20,1:20] # original values
pbmc@assays$RNA@layers$data[1:20,1:20] # normalised values
```

## 6. Identifying variable features

Genes that are not very variable across the dataset are not going to be very useful for clustering cells. Therefore, to perform our clustering we only want to take into account the 2000 genes that have the highest variance across the dataset. 
```{r}
pbmc <- FindVariableFeatures(pbmc, nfeatures = 2000)

# Get the 10 most highly variable genes
top10 <- head(VariableFeatures(pbmc), 10)

# plot variable features with and without labels
p <- VariableFeaturePlot(pbmc)
LabelPoints(p, points = top10, repel = TRUE)
```

## 7. Scaling the data

Here, we transform the data once again to shift the mean expression of each gene to 0, and the variance of each gene to 1. This is a standard pre-processing step to prevent highly expressed genes from having a too high influence on the clustering steps.  
```{r}
all.genes <- rownames(pbmc)
pbmc <- ScaleData(pbmc, features = all.genes)
```

Results are stored in: `pbmc@assays$RNA@layers$scale.data` 


> How can you confirm that the average expression for each gene is now 0?  

## 8. Principal component analysis (PCA)

You may remember that we briefly encountered PCA in the previous workshop. Explaining PCA in detail would take an entire lecture, but since this is not a statistics module, we will focus on the key ideas. 

PCA is a method to simplify complex data by finding patterns, called **principal components**, that allow a simpler representation of the data.

Here, we run a PCA using the `RunPCA` function in Seurat, focusing on the variable genes identified above. 
```{r eval=F}
pbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc), npcs = 50) # we calculate the first 50 PCs
```

Principal components are numbered based on how much variation (or spread) in the data they explain. We can visualise the first two principal components (PC1 and PC2) in a 2D plot:
```{r}
DimPlot(pbmc, reduction = "pca") + NoLegend()
```

Each principal component is associated with specific genes whose expression levels correlate with the pattern that the PC explains. Typically, these genes are co-expressed in distinct subsets of cells, creating identifiable patterns. Heatmaps can be used to visualise the expression of genes associated with each PC across all cells:
```{r fig.width=12, fig.height=10}
DimHeatmap(pbmc, dims = 1:9, cells = 500, balanced = TRUE)
```

We can see that the top PCs (e.g., PC1 and PC2) show strong patterns of correlated gene expression, meaning the associated genes are either highly expressed or absent in specific cells. These patterns highlight major sources of variation in the dataset. In contrast, the patterns in PC8 or PC9 are less distinct, capturing smaller or more subtle sources of variability.

After performing PCA, we need to determine how many PCs to use for the next steps. We know that we should use the top PCs as they represent a large part of the variance in the data, but where do we draw the line? 
To help, we draw an *elbow plot* to represent the proportion of variance explained by each PC. 
```{r}
ElbowPlot(pbmc)
```

We see that most of the variance is represented in PCs 1-10, so we will use these PCs to run the next steps. Note that this decision is based on a visual interpretation of a graph and should be considered an estimate. There is no ground truth for how many PCs to selected, and bioinformaticians often compare different numbers of PCs in downstream analyses.. 

## 9. Clustering

For clustering, Seurat groups similar cells by creating a graph where each cell is connected to its closest neighbours. It then uses an algorithm to divide the cells into clusters based on how connected they are. The number of clusters depends on a setting called "resolution," which can be adjusted. The final clusters are stored and can be accessed for further analysis.

```{r eval=F}
pbmc <- FindNeighbors(pbmc, dims = 1:10)
pbmc <- FindClusters(pbmc, resolution = 0.5)
```

After this, each cell is assigned to a cluster. This can be accessed using the following command:
```{r eval=F}
head(Idents(pbmc), 10) # using the `head` function to see only the first 10 cells
```

## 10. Dimensionality reduction

tSNE and UMAP are techniques to visualise multidimensional data in 2D. Cells grouped together in the previous step should colocalise on these dimensionality reduction plots, creating `clusters` of cells with similar transcriptomes. These methods are great for visualisation but because they represent a simplified view of the data, they should not be used to draw biological conclusions. Indeed, distance between clusters should not be used as a metric for estimating how different two clusters are from each other. 

```{r eval=F}
pbmc <- RunUMAP(pbmc, dims = 1:10)
pbmc <- RunTSNE(pbmc, dims = 1:10)
```

```{r}
DimPlot(pbmc, reduction = "umap")
DimPlot(pbmc, reduction = "tsne")
```

> At this stage, it is worth taking the time to go back and change parameters, to see how they influence the final results. For example, what happens if you change the number of variable genes in **6**, the resolution in **9** or the number of PCs used for clustering in **9** and **10**?

## 11. Finding markers

Each cell cluster had a specific transcriptome, and identifying genes that are specifically expressed in certain clusters is essential to allow their identification. Many comparisons can be performed, such as:
```{r eval=F}
markers_1v3 <- FindMarkers(pbmc, ident.1=1, ident.2=3) # finding all genes differently regulated between clusters 1 and 3
head(markers_1v3, n = 5)
```

or
```{r eval=F}
pbmc.markers <- FindAllMarkers(pbmc, only.pos = TRUE) # finding markers for each cluster vs the rest. NOTE: this will take a few minutes to run as all clusters are analysed in sequence. (The `only.pos` command only selects genes that are up-regulated in each cluster). 
pbmc.markers %>%
    group_by(cluster) %>%
    dplyr::filter(avg_log2FC > 1)
```

> Use the help (`?FindMarkers`) to understand what information is contained in each column of the `pbmc.markers` table
> Find some information about certain markers on your favourite gene database (or Google). Can you use this information to guess the identity of some clusters? (Remember the cells are all peripheral blood mononuclear cells.)
> Can you find out how many genes are specifically expressed in each cluster (`avg_log2FC>1` and `p_val_adj<0.05`)
> (Optional and challenging) can you generate a volcano plot to represent differential expression between two clusters of your choice?

## 12. Visualisation

Seurat offers many options to visualise gene expression across clusters:

#### Violin plots

Expression of genes of interest can be effectively visualised with `violin plots` These plots show normalised expression levels in all cells, and a violin-like shape to represent their distribution. For example: 
```{r}
VlnPlot(pbmc, features = c("MS4A1", "CD79A"))
```

> What happens if you add the `slot="counts"` argument to the command?
> Generate a few variants for other genes of your choice

#### Feature plots

These plots represent a very visual way to indicate where individual genes are expressed.  
```{r eval=F, fig.width=8, fig.height=8}
FeaturePlot(pbmc, features = c("MS4A1", "GNLY", "CD3E", "CD14"))
```

> Generate a few variants for other genes of your choice

#### Heatmaps

These allow visualisation of many genes across all clusters in a single figure:
```{r}
pbmc.markers %>%
    group_by(cluster) %>%
    dplyr::filter(avg_log2FC > 1) %>%
    slice_head(n = 10) %>% # here we select the top 10 markers in each cluster
    ungroup() -> top10
DoHeatmap(pbmc, features = top10$gene) + NoLegend()
```

> (Optional) if you have time, use the [data visualisation](https://satijalab.org/seurat/articles/visualization_vignette) vignette from the Seurat website to generate (1) a ridge plot, (2) a dot plot and (3) an interactive feature plot

## 13. Cluster annotation

In the case of this dataset, we have sufficient information to assign each cluster to a known cell type. Therefore, we can edit cluster names to replace numbers with actual cell types. 
```{r}
new.cluster.ids <- c("Naive CD4 T", "CD14+ Mono", "Memory CD4 T", "B", "CD8 T", "FCGR3A+ Mono",
    "NK", "DC", "Platelet")
names(new.cluster.ids) <- levels(pbmc)
pbmc <- RenameIdents(pbmc, new.cluster.ids)
DimPlot(pbmc, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()
```

<br/>
<br/>

<h1 align="center">The end</h1>
<p align="center">(you are now an expert!)</p>
